<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bekefendi Studio Pro - Visual Experience</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://w.soundcloud.com/player/api.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.2/color-thief.umd.js"></script>
    <!-- 3D MODU İÇİN THREE.JS KÜTÜPHANESİ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- TEMEL AYARLAR --- */
        * { box-sizing: border-box; }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; /* DÜZELTME: Body'nin arka plan rengini kaldırarak alttaki katmanların görünmesini sağla */
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex; justify-content: center; align-items: center;
        }

        /* --- YENİ: VIGNETTE VE GRID EFEKTLERİ --- */
        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -7; /* Grid'in üzerinde olması için */
            background: radial-gradient(circle at center, transparent 40%, black 100%);
            opacity: var(--vignette-opacity, 0); /* DÜZELTME: CSS Değişkenini kullan */
            transition: opacity 0.5s ease-out;
            pointer-events: none;
        }

        #grid-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: -9;
            pointer-events: none;
        }

        /* --- GİRİŞ ANİMASYONU --- */
        @keyframes fadeInSlideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* --- ARKA PLAN --- */
        #bg-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #120524, #4a0e45, #15082b, #4a0e45);
            background-size: 300% 300%;
            filter: blur(40px) brightness(0.4); /* DÜZELTME: Parlaklığı daha da düşür */ z-index: -10;
            transition: filter 0.5s ease-out;
            animation: animatedGradient 25s ease infinite;
        }
        @keyframes animatedGradient {
            0%{background-position:0% 50%} 50%{background-position:100% 50%} 100%{background-position:0% 50%}
        }
        #bg-layer::after {
            content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: -8;
            background-size: cover; background-position: center;
            opacity: 0; /* Başlangıçta görünmez */
            transition: opacity 1.5s ease-in-out; /* Yavaş ve yumuşak geçiş */
        }
        
        #particle-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: -5; pointer-events: none; transition: opacity 0.5s;
        }

        .main-container {
            display: flex; gap: 20px; align-items: stretch;
            height: 85vh; width: 90vw; max-width: 1400px;
            animation: fadeInSlideUp 0.8s ease-out forwards;
        }

        /* --- SOL PANEL --- */
        .visualizer-panel {
            flex: 2; /* Daha fazla yer kaplaması için flex değerini artır */ background: rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(30px); border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 25px; box-shadow: 0 30px 60px rgba(0,0,0,0.6);
            position: relative; overflow: hidden;
            transition: transform 0.1s ease-out;
        }

        /* --- KONTROL İKONLARI --- */
        .icon-controls {
            position: absolute;
            top: 15px;
            right: 20px;
            z-index: 25;
            display: flex;
            gap: 5px;
        }
        .control-btn {
            cursor: pointer; color: rgba(255,255,255,0.4);
            font-size: 1.1rem; transition: all 0.2s ease;
            padding: 10px; border-radius: 50%;
            width: 40px; height: 40px;
            display: flex; justify-content: center; align-items: center;
        }
        .control-btn:hover { color: rgba(255,255,255,0.9); transform: scale(1.1); background: rgba(0,0,0,0.2); }

        /* --- AYARLAR PANELİ --- */
        #settings-panel {
            position: absolute;
            top: 70px;
            right: 20px;
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            z-index: 100;
            width: 280px;
            color: #eee;
            visibility: hidden;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease-out;
        }
        #settings-panel.visible {
            visibility: visible;
            opacity: 1;
            transform: translateY(0);
        }
        .setting-item { margin-bottom: 15px; }
        .setting-item label { display: block; margin-bottom: 8px; font-size: 0.9rem; color: #aaa; }
        .setting-item input[type="range"] { width: 100%; }
        .toggle-switch { display: flex; justify-content: space-between; align-items: center; }
        /* Basit bir toggle switch stili */
        .switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #d500f9; }
        input:checked + .slider:before { transform: translateX(20px); }


        #canvas-visualizer, #canvas-3d {
            position: absolute; top: 0; left: 0;
            display: block; width: 100%; height: 100%;
            transition: opacity 0.3s ease-in-out;
        }

        /* --- ŞARKI BİLGİSİ --- */
        .info-wrapper {
            position: absolute; top: 50%; left: 50%; width: 80%;
            transform: translate(-50%, -50%); text-align: center;
            z-index: 15; pointer-events: none;
        }
        .track-title {
            font-size: 2.5rem; font-weight: 800; color: #fff; margin: 0;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.7), 0 0 20px rgba(213, 0, 249, 0.5);
            white-space: nowrap; overflow: hidden;
            transition: text-shadow 0.1s ease-out;
        }
        .track-title.scrolling > span {
            display: inline-block; padding-left: 100%;
            animation: marquee 15s linear infinite;
        }
        @keyframes marquee {
            0%   { transform: translateX(0); } 100% { transform: translateX(-100%); }
        }
        .track-title > span { display: inline-block; }
        .track-artist {
            font-size: 1rem; font-weight: 400; color: rgba(255,255,255,0.7); margin-top: 10px;
            letter-spacing: 2px; text-transform: uppercase;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            transition: text-shadow 0.1s ease-out;
        }

        /* --- KONTROLLER --- */
        .controls-wrapper {
            position: absolute; bottom: 30px; left: 0; width: 100%;
            text-align: center; z-index: 20; pointer-events: none;
        }
        .live-btn {
            pointer-events: auto; background: linear-gradient(90deg, #7b1fa2 0%, #4a148c 100%);
            color: white; border: none; padding: 12px 30px; border-radius: 50px;
            font-weight: 600; font-size: 0.9rem; cursor: pointer;
            box-shadow: 0 0 20px rgba(123, 31, 162, 0.4);
            display: inline-flex; align-items: center; gap: 10px; transition: all 0.2s;
        }
        .live-btn:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(123, 31, 162, 0.6); }
        .hint {
            margin-top: 10px; font-size: 0.8rem; color: rgba(255,255,255,0.4);
            pointer-events: auto; background: rgba(0,0,0,0.5);
            display: inline-block; padding: 5px 10px; border-radius: 10px;
        }
        .explanation-text {
            margin-top: 8px; font-size: 0.75rem; color: rgba(255,255,255,0.5);
            max-width: 380px; /* Genişliğin çok artmasını önle */
            margin-left: auto; margin-right: auto;
            line-height: 1.4;
        }

        /* --- SAĞ PANEL --- */
        .sc-panel {
            flex: 0 0 380px; /* Sabit genişlik, büyümesin veya küçülmesin */
            max-width: 380px; /* Genişliği sınırla */
            background: rgba(10, 10, 10, 0.9); border-radius: 25px;
            overflow: hidden; border: 1px solid rgba(255, 255, 255, 0.05);
            display: flex; flex-direction: column;
        }
        #sc-frame { width: 100%; height: 100%; border: none; }
        #file-upload { display: none; }

        /* --- MOBİL UYUMLULUK --- */
        @media (max-width: 768px) {
            body, html { overflow: auto; align-items: flex-start; }
            .main-container { flex-direction: column; height: auto; width: 100%; padding: 15px; gap: 15px; }
            .visualizer-panel { flex: 0 0 300px; cursor: default; }
            .sc-panel { flex: 1; min-height: 400px; }
            .info-wrapper { top: 65%; }
            .track-title { font-size: 1.5rem; }
            .track-artist { font-size: 0.8rem; }
            .controls-wrapper, #settings-panel { display: none; } /* Ayarları mobilde gizle */
        }

        /* --- YÜKLEME EKRANI --- */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #050505; z-index: 9999; display: flex;
            justify-content: center; align-items: center;
            transition: opacity 0.7s ease, visibility 0.7s ease;
            opacity: 1; visibility: visible;
        }
        #loader.hidden { opacity: 0; visibility: hidden; }
        .spinner {
            width: 60px; height: 60px; border: 5px solid rgba(255, 255, 255, 0.2);
            border-top-color: #d500f9; border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loader"><div class="spinner"></div></div>
    <canvas id="grid-canvas"></canvas>
    <canvas id="particle-canvas"></canvas>
    <div id="bg-layer"></div>

    <div class="main-container">

        <div class="visualizer-panel" id="viz-panel">
            <canvas id="canvas-visualizer"></canvas>
            <canvas id="canvas-3d"></canvas>

            <div class="icon-controls">
                <div id="settings-btn" class="control-btn" title="Ayarlar">
                    <i class="fa-solid fa-gear"></i>
                </div>
                <div id="artist-switcher" class="control-btn" title="Sanatçıyı Değiştir">
                    <i class="fa-solid fa-right-left"></i>
                </div>
                <div id="style-switcher" class="control-btn" title="Görselleştirici Stilini Değiştir">
                    <i class="fa-solid fa-circle-notch"></i>
                </div>
            </div>

            <div id="settings-panel">
                <div class="setting-item">
                    <label for="effect-intensity">Efekt Yoğunluğu</label>
                    <input type="range" id="effect-intensity" min="0" max="2" value="1" step="0.1">
                </div>
                <div class="setting-item">
                    <label for="bg-blur">Arka Plan Bulanıklığı</label>
                    <input type="range" id="bg-blur" min="0" max="80" value="40" step="1">
                </div>
                <div class="setting-item">
                    <div class="toggle-switch">
                        <label for="particle-toggle">Parçacık Efekti</label>
                        <label class="switch">
                            <input type="checkbox" id="particle-toggle" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="info-wrapper">
                <h2 class="track-title" id="track-title"><span>BEKEFENDI STUDIO</span></h2>
                <p class="track-artist" id="track-artist">Ready to play</p>
            </div>

            <div class="controls-wrapper">
                <button class="live-btn" id="start-btn">
                    <i class="fa-solid fa-broadcast-tower"></i> CANLI SENKRONİZASYONU BAŞLAT
                </button>
                <div class="hint">
                    <i class="fa-solid fa-triangle-exclamation"></i> <b>"Bu Sekme (This Tab)"</b> seç ve <b>"Sesi Paylaş"</b>ı işaretle.
                </div>
                <div class="explanation-text">
                    Bu mod, görsel efektlerin çalan müziğe gerçek zamanlı tepki vermesini sağlar. (Daha yüksek sistem kaynağı gerektirebilir)
                </div>
            </div>
        </div>

        <div class="sc-panel">
            <iframe id="sc-frame" 
                    scrolling="auto" frameborder="no" allow="autoplay" 
                    src="https://w.soundcloud.com/player/?url=https%3A//soundcloud.com/bekefendi&color=%237b1fa2&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=false">
            </iframe>
        </div>
    </div>

    <script>
        // --- DOM ELEMENTLERİ ---
        const loader = document.getElementById('loader');
        const canvas = document.getElementById('canvas-visualizer');
        const ctx = canvas.getContext('2d');
        const canvas3D = document.getElementById('canvas-3d');
        const gridCanvas = document.getElementById('grid-canvas');
        const gCtx = gridCanvas.getContext('2d');
        const particleCanvas = document.getElementById('particle-canvas');
        const pCtx = particleCanvas.getContext('2d'); 
        const startBtn = document.getElementById('start-btn');
        const bgLayer = document.getElementById('bg-layer');
        const vizPanel = document.getElementById('viz-panel');
        const titleEl = document.getElementById('track-title');
        const styleSwitcher = document.getElementById('style-switcher');
        const artistSwitcher = document.getElementById('artist-switcher');
        const artistEl = document.getElementById('track-artist');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsPanel = document.getElementById('settings-panel');
        const effectIntensitySlider = document.getElementById('effect-intensity');
        const bgBlurSlider = document.getElementById('bg-blur');
        const particleToggle = document.getElementById('particle-toggle');
 
        // --- GLOBAL DEĞİŞKENLER ---
        let audioContext, analyser;
        let currentMode = 'simulation'; // 'simulation' veya 'realtime'
        let isPlaying = false; // SoundCloud widget'ının durumunu takip eder
        let currentPalette = [[213, 0, 249], [0, 229, 255]];
        let targetPalette = [[213, 0, 249], [0, 229, 255]];
        let rotationAngle = 0;
        let simulationBeatInterval;
        let trackChangeInterval;

        // --- AYARLAR (KULLANICI KONTROLLERİ) ---
        let settings = {
            effectIntensity: 1,
            backgroundBlur: 40,
            useParticles: true,
        };

        // --- SANATÇI VE STİL YÖNETİMİ ---
        const artists = [
            { name: 'Bekefendi', url: 'https://soundcloud.com/bekefendi' },
            { name: 'yxng_anxty', url: 'https://soundcloud.com/yxng_anxty' }
        ];
        let currentArtistIndex = 0;
        const visualizerStyles = [
            { name: 'circle', icon: 'fa-solid fa-circle-notch' },
            { name: 'line', icon: 'fa-solid fa-bars-staggered' },
            { name: 'mirror', icon: 'fa-solid fa-water' },
            { name: 'pulse', icon: 'fa-solid fa-bullseye' },
            { name: '3d-sphere', icon: 'fa-solid fa-globe' },
            { name: '3d-orb', icon: 'fa-solid fa-atom' } // YENİ: Enerji Küresi
        ];
        let currentStyleIndex = 0;
        
        // --- RESİM YÖNETİMİ ---
        const defaultImageBase64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII=";
        let recordImg = new Image();
        recordImg.crossOrigin = "anonymous";
        recordImg.src = defaultImageBase64; 
        recordImg.onload = () => {
            try {
                const colorThief = new ColorThief();
                const newPalette = colorThief.getPalette(recordImg, 2);
                if (newPalette) targetPalette = newPalette;
                if (three.albumArtTexture) three.albumArtTexture.needsUpdate = true;
            } catch (e) {
                targetPalette = [[213, 0, 249], [0, 229, 255]];
            }
            // drawStatic çağrısı kaldırıldı, mainLoop zaten sürekli çizim yapıyor.
        };

        // --- SOUNDCLOUD WIDGET ---
        var iframeElement = document.querySelector('#sc-frame');
        var widget;
        function initializeWidget() {
            widget = SC.Widget(iframeElement);
            widget.bind(SC.Widget.Events.READY, function() {
                // Yükleyiciyi gizle ve ana animasyon döngüsünü başlat
                loader.classList.add('hidden'); 
                widget.unbind(SC.Widget.Events.PLAY); widget.unbind(SC.Widget.Events.PAUSE); widget.unbind(SC.Widget.Events.FINISH);
                widget.bind(SC.Widget.Events.PLAY, updateTrackInfo);
                widget.bind(SC.Widget.Events.PLAY, () => { isPlaying = true; startSimulationBeat(); });
                widget.bind(SC.Widget.Events.PAUSE, () => { isPlaying = false; stopSimulationBeat(); });
                widget.bind(SC.Widget.Events.FINISH, () => setTimeout(updateTrackInfo, 1000));
            });
        }

        function updateTrackInfo() {
            widget.getCurrentSound(function(sound) {
                if (!sound) return;
                const titleSpan = titleEl.querySelector('span');
                titleSpan.innerText = sound.title;
                artistEl.innerText = sound.user.username;
                titleEl.classList.toggle('scrolling', titleSpan.offsetWidth > titleEl.offsetWidth);
                
                const bgAfter = document.querySelector('#bg-layer::after');

                if(sound.artwork_url) {
                    const highResUrl = sound.artwork_url.replace('-large', '-t500x500');
                    // DÜZELTME: Yumuşak geçiş için doğrudan değiştirmek yerine ::after elementini kullan
                    bgLayer.style.setProperty('--bg-image-url', `url('${highResUrl}')`);
                    recordImg.src = highResUrl;
                } else {
                    // Resim yoksa ::after elementini gizle
                    bgLayer.style.setProperty('--bg-image-url', 'none');
                    targetPalette = [[213, 0, 249], [0, 229, 255]];
                }
            });
        }

        // --- KONTROL EVENTLERİ ---
        function resizeCanvas() {
            const w = vizPanel.offsetWidth;
            const h = vizPanel.offsetHeight;
            canvas.width = w; canvas.height = h;
            canvas3D.width = w; canvas3D.height = h;
            gridCanvas.width = window.innerWidth;
            gridCanvas.height = window.innerHeight;
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
            if (three.renderer) { three.renderer.setSize(w, h); three.renderer.setPixelRatio(window.devicePixelRatio); }
            if (three.camera) { three.camera.aspect = w / h; three.camera.updateProjectionMatrix(); }
        }
        window.addEventListener('resize', resizeCanvas);
        setTimeout(resizeCanvas, 100);

        artistSwitcher.onclick = function(event) {
            event.stopPropagation();
            currentArtistIndex = (currentArtistIndex + 1) % artists.length;
            const newArtist = artists[currentArtistIndex];
            loader.classList.remove('hidden');
            const baseUrl = "https://w.soundcloud.com/player/?url=";
            const params = "&color=%237b1fa2&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=false";
            iframeElement.src = baseUrl + newArtist.url + params;
            iframeElement.onload = initializeWidget;
            if (trackChangeInterval) {
                clearInterval(trackChangeInterval);
                trackChangeInterval = null;
            }
        }

        styleSwitcher.onclick = function(event) {
            event.stopPropagation();
            canvas.style.opacity = '0';
            canvas3D.style.opacity = '0';
            setTimeout(() => {
                currentStyleIndex = (currentStyleIndex + 1) % visualizerStyles.length;
                const newStyle = visualizerStyles[currentStyleIndex];
                styleSwitcher.querySelector('i').className = newStyle.icon;
                if (newStyle.name.startsWith('3d-')) {
                    canvas.style.display = 'none';
                    canvas3D.style.display = 'block';
                    if (!three.initialized) three.init();
                } else {
                    canvas.style.display = 'block';
                    canvas3D.style.display = 'none';
                }
                canvas.style.opacity = '1';
                canvas3D.style.opacity = '1';
            }, 300);
        }

        settingsBtn.onclick = (e) => {
            e.stopPropagation();
            settingsPanel.classList.toggle('visible');
        };
        document.onclick = (e) => {
            if (!settingsPanel.contains(e.target) && !settingsBtn.contains(e.target)) {
                settingsPanel.classList.remove('visible');
            }
        };
        effectIntensitySlider.oninput = (e) => settings.effectIntensity = parseFloat(e.target.value);
        bgBlurSlider.oninput = (e) => {
            settings.backgroundBlur = parseFloat(e.target.value);
            if (currentMode === 'simulation') bgLayer.style.filter = `blur(${settings.backgroundBlur}px) brightness(0.6) hue-rotate(${hueShiftAngle}deg)`;
        };
        particleToggle.onchange = (e) => {
            settings.useParticles = e.target.checked;
            particleCanvas.style.opacity = settings.useParticles ? '1' : '0';
        };
        
        // --- SİSTEM BAŞLATMA / DURDURMA ---
        startBtn.onclick = async function() { 
            if (currentMode === 'realtime') { stopSystem(); return; }
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({
                    video: true, audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }, 
                    selfBrowserSurface: "include", systemAudio: "include" 
                });
                if (stream.getAudioTracks().length === 0) {
                    stream.getTracks().forEach(track => track.stop());
                    alert("HATA: 'Sesi Paylaş' kutucuğunu işaretlemedin!");
                    return;
                }
                stopSimulationBeat(); // Simülasyonu durdur
                currentMode = 'realtime';
                startBtn.innerHTML = '<i class="fa-solid fa-stop-circle"></i> CANLIYI DURDUR';
                startBtn.style.background = "#d32f2f"; // Kırmızı tonu
                stream.getTracks()[0].onended = () => stopSystem();
                resizeCanvas();
                setupAudioAnalysis(stream);
            } catch (err) { if (err.name !== 'NotAllowedError') alert("Hata: " + err.message); }
        };

        function stopSystem() {
            if (trackChangeInterval) { clearInterval(trackChangeInterval); trackChangeInterval = null; }
            currentMode = 'simulation';
            startBtn.innerHTML = '<i class="fa-solid fa-broadcast-tower"></i> CANLI SENKRONİZASYONU BAŞLAT';
            startBtn.disabled = false;
            startBtn.style.background = "linear-gradient(90deg, #7b1fa2 0%, #4a148c 100%)";
            
            // DÜZELTME: Yumuşak geçiş için arka planı sıfırla
            const bgAfter = document.querySelector('#bg-layer::after');
            bgLayer.style.setProperty('--bg-image-url', 'none');

            bgLayer.style.filter = `blur(${settings.backgroundBlur}px) brightness(0.6)`;
            document.body.style.setProperty('--vignette-opacity', '0');
            titleEl.style.textShadow = ''; artistEl.style.textShadow = '';
            if(audioContext) audioContext.close();
        }

        // --- SES ANALİZİ VE EFEKTLER ---
        let lastBeatTime = 0, beatIntervals = [], currentBPM = 120, smoothedBPM = 120, beatIntensity = 0;
        const PALETTES = {
            ENERGETIC: [[255, 0, 80], [255, 100, 0]], // Kırmızı/Turuncu
            DARK: [[130, 0, 255], [20, 20, 40]], // Mor/Koyu Mavi
            CHILL: [[0, 255, 150], [0, 150, 255]], // Turkuaz/Mavi
            ATMOSPHERIC: [[220, 220, 255], [150, 180, 255]] // Açık Pastel
        };

        function setupAudioAnalysis(stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext.state === 'suspended') audioContext.resume();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            analyser.fftSize = 256;
            analyser.smoothingTimeConstant = 0.8;
            const bufferLength = analyser.frequencyBinCount;
            startTrackChangeInterval();
        }

        function processAudioData(sourceData, numBars) {
            if (!sourceData) return new Uint8Array(numBars).fill(0);
            const processedData = new Uint8Array(numBars);
            const sourceLength = sourceData.length;
            const step = Math.floor(sourceLength / numBars);
            if (step < 1) return sourceData;

            for (let i = 0; i < numBars; i++) {
                const start = i * step;
                const end = start + step;
                let sum = 0;
                for (let j = start; j < end; j++) {
                    sum += sourceData[j];
                }
                processedData[i] = sum / step;
            }
            return processedData;
        }

        // --- SİMÜLASYON MODU FONKSİYONLARI ---
        function startSimulationBeat() {
            if (simulationBeatInterval || currentMode !== 'simulation' || !isPlaying) return;
            const bpm = 120; // Ortalama bir BPM değeri
            const interval = 60000 / bpm;
            simulationBeatInterval = setInterval(() => {
                beatIntensity = 1; // Vuruş anında enerjiyi 1 yap
                if (visualizerStyles[currentStyleIndex].name === 'pulse') createShockwave(150);
            }, interval);
        }

        function stopSimulationBeat() {
            clearInterval(simulationBeatInterval);
            simulationBeatInterval = null;
        }

        // --- ANA ANİMASYON DÖNGÜSÜ ---
        let lowPass = 0;
        // YENİ: Gelişmiş simülasyon için durum değişkenleri
        const sim = {
            time: 0,
            bassPulse: 0,
            treblePulse: 0,
            lastBassBeat: 0,
            lastTrebleBeat: 0,
            bassInterval: 60000 / 120, 
            trebleInterval: (60000 / 120) / 2,
        };

        let patternTime = 0; // YENİ: Desen animasyonları için zamanlayıcı
        function mainLoop() {
            let trebleAvg = 0;
            requestAnimationFrame(mainLoop);

            let dataArray = null;
            let bassAvg = 0;
            const now = Date.now();

            if (currentMode === 'realtime' && analyser) {
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                analyser.getByteFrequencyData(dataArray);

                // Gerçek bass ortalamasını daha doğru hesapla
                let bassSum = 0, trebleSum = 0;
                const bassEnd = Math.floor(bufferLength * 0.15);
                const trebleStart = Math.floor(bufferLength * 0.4);
                const trebleEnd = Math.floor(bufferLength * 0.8);

                for (let i = 0; i < bassEnd; i++) bassSum += dataArray[i];
                for (let i = trebleStart; i < trebleEnd; i++) trebleSum += dataArray[i];

                bassAvg = (bassSum / bassEnd) * 1.2 || 0; // Bası biraz daha vurgula
                trebleAvg = (trebleSum / (trebleEnd - trebleStart)) || 0;

                // Gerçek zamanlı BPM ve vuruş tespiti
                lowPass = lowPass * 0.9 + 0.1 * bassAvg;
                if (bassAvg > lowPass + 35 && Date.now() - lastBeatTime > 250) {
                    lastBeatTime = Date.now();
                    beatIntensity = 1;
                    if (visualizerStyles[currentStyleIndex].name === 'pulse') createShockwave(bassAvg);
                }
            } else { // YENİ: Estetik Desen Simülasyonu
                patternTime += 0.01;
                
                // DEĞİŞİKLİK: "Patlama" efekti yerine sakin bir "nefes alma" efekti.
                if (isPlaying) {
                    beatIntensity = Math.sin(patternTime * 2) * 0.5 + 0.5; // 0 ile 1 arasında yumuşakça salınır.
                } else {
                    beatIntensity *= 0.95; // Müzik durduğunda efekti yavaşça söndür.
                }

                // 3D Küre için hala sahte dataArray gerekiyor
                if (visualizerStyles[currentStyleIndex].name.startsWith('3d-')) {
                    const bufferLength = 128;
                    dataArray = new Uint8Array(bufferLength);
                    for (let i = 0; i < bufferLength; i++) {
                        const a = Math.sin(patternTime * 2 + i * 0.2) * 0.5 + 0.5;
                        dataArray[i] = a * 100 + beatIntensity * 150;
                    }
                    bassAvg = dataArray[0] || 0;
                } else {
                    // Diğer stiller için doğrudan canvas'a çizim yap
                    dataArray = null; 
                    bassAvg = (Math.sin(patternTime * 2) * 0.5 + 0.5) * 150 + beatIntensity * 100;
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const style = visualizerStyles[currentStyleIndex].name;
                    titleEl.style.opacity = artistEl.style.opacity = (style === 'circle' || style === 'pulse') ? '1' : '0';

                    switch (style) {
                        case 'circle':
                            drawSimCirclePattern(patternTime, beatIntensity);
                            drawRecordPlayer(isPlaying);
                            break;
                        case 'line':
                            drawSimLinePattern(patternTime, beatIntensity);
                            break;
                        case 'mirror':
                            drawSimMirrorPattern(patternTime, beatIntensity);
                            break;
                        case 'pulse':
                            drawSimPulsePattern(patternTime, beatIntensity);
                            break;
                    }
                }
            }

            // Renkleri yumuşakça hedefe doğru ilerlet
            for(let i=0; i<2; i++) for(let j=0; j<3; j++) currentPalette[i][j] += (targetPalette[i][j] - currentPalette[i][j]) * 0.02;

            // DÜZELTME: Vuruş enerjisini her zaman azalt. Bu, efektlerin takılı kalmasını önler.
            if (currentMode === 'realtime') beatIntensity *= 0.92;

            // --- VURUŞ ENERJİSİNE DAYALI EFEKTLER (AYARLANABİLİR) ---
            const intensity = settings.effectIntensity;
            const panelScale = 1 + (beatIntensity * 0.015 * intensity);
            vizPanel.style.transform = `scale(${panelScale})`;
            let brightness = 0.6 + (bassAvg / 255) * 1.4 + (beatIntensity * 0.15 * intensity);
            document.body.style.setProperty('--vignette-opacity', String(beatIntensity * 0.6 * intensity));
            let hueRotate = (bassAvg / 1.5);
            bgLayer.style.filter = `blur(${settings.backgroundBlur}px) brightness(${brightness}) hue-rotate(${hueRotate}deg)`;
            const textGlow = (bassAvg / 255) * 25;
            titleEl.style.textShadow = `0 0 ${10 + textGlow}px rgba(255, 255, 255, 0.7), 0 0 ${20 + textGlow * 1.5}px rgba(213, 0, 249, 0.5)`;
            artistEl.style.textShadow = `0 0 ${2 + textGlow * 0.2}px rgba(255, 255, 255, 0.5)`;

            // Çizim fonksiyonlarını çağır
            // Simülasyon modunda çizim yukarıda switch-case içinde yapılıyor.
            if (currentMode === 'realtime') {
                drawFrame(dataArray, isPlaying, beatIntensity * intensity);
            }
            drawGrid(beatIntensity * intensity);
            animateParticles(); // Parçacık animasyonunu ana döngüden çağır
            if (three.initialized) three.update(dataArray, beatIntensity * intensity, bassAvg, trebleAvg);
        }

        function startTrackChangeInterval() {
            if (trackChangeInterval) clearInterval(trackChangeInterval);
            let lastPlayedSoundId = null;
            trackChangeInterval = setInterval(() => {
                if (!widget) return;
                widget.getCurrentSound((currentSound) => {
                    if (currentSound && currentSound.id !== lastPlayedSoundId) {
                        lastPlayedSoundId = currentSound.id;
                        updateTrackInfo();
                    }
                });
            }, 1000);
        }

        // --- 2D ÇİZİM FONKSİYONLARI ---
        function drawFrame(dataArray, isAnimating, beatIntensity = 0) {
            if (!dataArray) return; // Eğer data yoksa çizim yapma (simülasyon modu için)
            const processedData = processAudioData(dataArray, 64); // Veriyi 64 çubuğa indirge
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const style = visualizerStyles[currentStyleIndex].name;
            const is3D = style.startsWith('3d-');
            titleEl.style.opacity = artistEl.style.opacity = (is3D || style === 'line' || style === 'mirror') ? '0' : '1';
            if (style === 'circle') drawCircleVisualizer(processedData, beatIntensity);
            else if (style === 'line') drawLineVisualizer(processedData, beatIntensity);
            else if (style === 'mirror') drawMirrorVisualizer(processedData, beatIntensity);
            else if (style === 'pulse') drawPulseVisualizer(processedData, beatIntensity);
            if (style === 'circle') drawRecordPlayer(isAnimating);
        }
        function drawCircleVisualizer(dataArray, beatIntensity) {
            const centerX = canvas.width / 2, centerY = canvas.height / 2, radius = 160;
            if (!dataArray) return;

            // OPTİMİZASYON: Her çizgi için gölge çizmek yerine, tüm çizgileri tek seferde çiz.
            // VE: Tüm çizgileri tek bir path'de birleştirerek çizim çağrılarını azalt.
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.shadowColor = getRainbowColor(patternTime + 0.5);
            ctx.shadowBlur = 15;
            
            ctx.beginPath(); // Tüm çizgiler için tek bir path başlat
            for (let i = 0; i < dataArray.length; i++) {
                // YENİ: Gelişmiş Kanal Dengeleme (Bas Enerjisi Aktarımı)
                const rawValue = dataArray[i];
                const progress = i / dataArray.length;
                const bassEnergy = (dataArray[0] + dataArray[1]) / 2;
                const bassContribution = bassEnergy * progress * 0.5; // Sona doğru bas etkisini artır
                const dynamicValue = Math.pow(rawValue, 0.9) + bassContribution;
                const value = Math.min(255, dynamicValue);
                const beatMultiplier = 1 + (beatIntensity * 0.25);
                const barHeight = (value * 0.9 * beatMultiplier) + 5 ;
                const angle = (i * 2 * Math.PI) / dataArray.length;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                const xStart = centerX + cos * radius, yStart = centerY + sin * radius;
                const xEnd = centerX + cos * (radius + barHeight), yEnd = centerY + sin * (radius + barHeight);
                ctx.moveTo(xStart, yStart);
                ctx.lineTo(xEnd, yEnd);
            }
            ctx.strokeStyle = getRainbowColor(patternTime);
            ctx.stroke(); // Tüm çizgileri tek seferde çiz
        }
        function drawFadedArtwork() {
            if (recordImg.complete && recordImg.naturalWidth > 0) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const h = canvas.height;
                const w = (h / recordImg.height) * recordImg.width;
                ctx.save();
                ctx.globalAlpha = 0.1; // Soluk bir görünüm için
                ctx.drawImage(recordImg, centerX - w / 2, centerY - h / 2, w, h);
                ctx.restore();
            }
        }
        function drawLineVisualizer(dataArray, beatIntensity) {
            if (!dataArray) return;
            const numBars = dataArray.length;
            const barWidth = canvas.width / numBars;
            let x = 0;
            for (let i = 0; i < numBars; i++) {
                // DÜZELTME: Logaritmik güçlendirmeyi tüm efektlere uygula
                 const rawValue = dataArray[i];
                const progress = i / numBars;
                const bassEnergy = (dataArray[0] + dataArray[1]) / 2;
                const bassContribution = bassEnergy * progress * 0.4;
                const dynamicValue = Math.pow(rawValue, 0.9) + bassContribution;
                const value = Math.min(255, dynamicValue);
                const beatMultiplier = 1 + (beatIntensity * 0.3); 
                const barHeight = (value / 255) * (canvas.height * 0.7) * beatMultiplier;
                const color = getColorFromPalette(value);
                ctx.fillStyle = color; 
                ctx.shadowColor = color; 
                ctx.shadowBlur = 10;
                ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
            drawFadedArtwork();
        }
        function drawMirrorVisualizer(dataArray, beatIntensity) {
            if (!dataArray) return;
            const numBars = dataArray.length;
            const barWidth = canvas.width / numBars;
            const centerY = canvas.height / 2;
            let x = 0;
            for (let i = 0; i < numBars; i++) {
                // DÜZELTME: Logaritmik güçlendirmeyi tüm efektlere uygula
                 const rawValue = dataArray[i];
                const progress = i / numBars;
                const bassEnergy = (dataArray[0] + dataArray[1]) / 2;
                const bassContribution = bassEnergy * progress * 0.4;
                const dynamicValue = Math.pow(rawValue, 0.9) + bassContribution;
                const value = Math.min(255, dynamicValue);
                const beatMultiplier = 1 + (beatIntensity * 0.3); 
                const barHeight = (value / 255) * (canvas.height * 0.4) * beatMultiplier;
                const color = getColorFromPalette(value);
                ctx.fillStyle = color;
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;
                ctx.fillRect(x, centerY - barHeight, barWidth, barHeight);
                ctx.fillRect(x, centerY, barWidth, barHeight);
                x += barWidth + 1; // Çubuklar arası boşluk
            }
            drawFadedArtwork();
        }
        function drawPulseVisualizer(dataArray, beatIntensity) {
            const centerX = canvas.width / 2, centerY = canvas.height / 2;
            let bassAvg = 0;
            if (dataArray) {
                let bassSum = 0;
                for (let i = 0; i < dataArray.length * 0.3; i++) { bassSum += dataArray[i]; }
                bassAvg = bassSum / (dataArray.length * 0.3);
                const beatMultiplier = 1 + (beatIntensity * 0.25);
                pulseRadius = 50 + (bassAvg / 255) * 100 * beatMultiplier;
            }
            ctx.save();
            ctx.beginPath(); 
            ctx.arc(centerX, centerY, pulseRadius, 0, Math.PI * 2); 
            ctx.clip();
            ctx.shadowColor = getColorFromPalette(bassAvg);
            ctx.shadowBlur = 25;
            ctx.fillStyle = getColorFromPalette(bassAvg);
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (recordImg.complete && recordImg.naturalWidth > 0) {
                ctx.drawImage(recordImg, centerX - pulseRadius, centerY - pulseRadius, pulseRadius * 2, pulseRadius * 2);
            }
            ctx.restore();
            updateAndDrawShockwaves();
        } 

        // --- YENİ: SİMÜLASYON DESEN FONKSİYONLARI ---
        function drawSimCirclePattern(t, beat) {
            const centerX = canvas.width / 2, centerY = canvas.height / 2;
            const beatScale = 1 + beat * 0.2;
            ctx.lineWidth = 4;
            for (let i = 1; i < 5; i++) {
                const radius = (100 + i * 40 + Math.sin(t * 2 + i) * 10) * beatScale;
                const opacity = 0.3 + (Math.sin(t * 3 + i * 0.5) * 0.5 + 0.5) * 0.5;
                const color = getRainbowColor(t + i * 0.2, opacity);
                ctx.strokeStyle = color;
                ctx.shadowColor = color;
                ctx.shadowBlur = 25;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        function drawSimLinePattern(t, beat) {
            const numBars = 40;
            const barWidth = canvas.width / numBars;
            const beatHeight = beat * (canvas.height * 0.3);
            for (let i = 0; i < numBars; i++) {
                const phase = t * 3 + (i / numBars) * Math.PI * 4;
                const height = (Math.sin(phase) * 0.5 + 0.5) * (canvas.height * 0.5) + beatHeight;
                const color = getRainbowColor(t + i * 0.05);
                ctx.fillStyle = color;
                ctx.shadowColor = color;
                ctx.shadowBlur = 20;
                ctx.fillRect(i * barWidth, canvas.height - height, barWidth - 2, height);
            }
            drawFadedArtwork();
        }
        function drawSimMirrorPattern(t, beat) {
            const numBars = 50;
            const barWidth = canvas.width / numBars;
            const centerY = canvas.height / 2;
            const beatHeight = beat * (canvas.height * 0.2);
            for (let i = 0; i < numBars; i++) {
                const phase = t * 2 + (i / numBars) * Math.PI * 6;
                const height = (Math.sin(phase) * 0.5 + 0.5) * (canvas.height * 0.3) + beatHeight;
                const color = getRainbowColor(t + i * 0.04);
                ctx.fillStyle = color;
                ctx.shadowColor = color;
                ctx.shadowBlur = 20;
                ctx.fillRect(i * barWidth, centerY - height, barWidth - 2, height);
                ctx.fillRect(i * barWidth, centerY, barWidth - 2, height);
            }
            drawFadedArtwork();
        }
        function drawSimPulsePattern(t, beat) {
            const centerX = canvas.width / 2, centerY = canvas.height / 2;
            const baseRadius = 100 + Math.sin(t * 4) * 20;
            const radius = baseRadius + beat * 80;
            const color = getRainbowColor(t);
            ctx.save();
            ctx.beginPath(); ctx.arc(centerX, centerY, radius, 0, Math.PI * 2); ctx.clip();
            ctx.fillStyle = color; ctx.shadowColor = color; ctx.shadowBlur = 30;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (recordImg.complete && recordImg.naturalWidth > 0) {
                ctx.globalAlpha = 0.8;
                ctx.drawImage(recordImg, centerX - radius, centerY - radius, radius * 2, radius * 2);
            }
            ctx.restore();
            // DEĞİŞİKLİK: Sakin modda şok dalgası istenmiyor.
            updateAndDrawShockwaves();
        }

        // --- RENK YÖNETİMİ ---
        function getColorFromPalette(value) {
            const ratio = value / 255;
            const r = Math.round(currentPalette[0][0] * (1 - ratio) + currentPalette[1][0] * ratio);
            const g = Math.round(currentPalette[0][1] * (1 - ratio) + currentPalette[1][1] * ratio);
            const b = Math.round(currentPalette[0][2] * (1 - ratio) + currentPalette[1][2] * ratio);
            return `rgb(${r}, ${g}, ${b})`;
        }
        function getRainbowColor(t, opacity = 1) {
            const time = (t % 1); // 0-1 arasında döngü
            const ratio = time < 0.5 ? time * 2 : (1 - time) * 2; // Üçgen dalga (0 -> 1 -> 0)
            const r = Math.round(currentPalette[0][0] * (1 - ratio) + currentPalette[1][0] * ratio);
            const g = Math.round(currentPalette[0][1] * (1 - ratio) + currentPalette[1][1] * ratio);
            const b = Math.round(currentPalette[0][2] * (1 - ratio) + currentPalette[1][2] * ratio);
            return `rgba(${r}, ${g}, ${b}, ${opacity})`;
        }
        let shockwaves = [];
        function createShockwave(value) {
            if (shockwaves.length > 5) return;
            shockwaves.push({ x: canvas.width / 2, y: canvas.height / 2, radius: 30, opacity: 1, color: getColorFromPalette(value) });
        }
        function updateAndDrawShockwaves() {
            for (let i = shockwaves.length - 1; i >= 0; i--) {
                const wave = shockwaves[i];
                wave.radius += 3;
                wave.opacity -= 0.01;
                if (wave.opacity <= 0) {
                    shockwaves.splice(i, 1);
                } else {
                    ctx.strokeStyle = wave.color.replace('rgb', 'rgba').replace(')', `, ${wave.opacity})`);
                    ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2); ctx.stroke();
                }
            }
        }
        function drawRecordPlayer(isAnimating) {
            const centerX = canvas.width / 2, centerY = canvas.height / 2;
            ctx.save(); ctx.translate(centerX, centerY);
            // DÜZELTME: Takılma efektini önlemek için BPM'e bağlı dönüş yerine sabit hız kullan.
            // Bu, müziğin ritmi ne olursa olsun akıcı bir dönüş sağlar.
            if (isAnimating) rotationAngle += 0.01;

            ctx.rotate(rotationAngle);
            ctx.beginPath(); ctx.arc(0, 0, 150, 0, Math.PI * 2); ctx.closePath(); ctx.clip();
            if (recordImg.complete && recordImg.naturalWidth > 0) ctx.drawImage(recordImg, -150, -150, 300, 300);
            else { ctx.fillStyle = "#000"; ctx.fill(); }
            ctx.beginPath(); ctx.arc(0, 0, 150, 0, Math.PI * 2); ctx.lineWidth = 15; ctx.strokeStyle = "#111"; ctx.stroke();
            ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI * 2); ctx.fillStyle = "#000"; ctx.fill();
            ctx.restore();
        }

        // --- 3D YÖNETİMİ (THREE.JS) ---
        const three = {
            initialized: false, scene: null, camera: null, renderer: null, 
            sphereGroup: null, orbGroup: null,
            init: function() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(60, canvas3D.width / canvas3D.height, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ canvas: canvas3D, alpha: true });
                this.renderer.setSize(canvas3D.width, canvas3D.height);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Performans için sınrla

                // --- 3D KÜRE ---
                const geometry = new THREE.IcosahedronGeometry(2, 64);
                geometry.setAttribute('basePosition', new THREE.BufferAttribute(geometry.attributes.position.array.slice(), 3));
                const material = new THREE.MeshStandardMaterial({ color: 0xffffff, wireframe: true });
                const sphere = new THREE.Mesh(geometry, material);
                this.sphereGroup = new THREE.Group();
                this.sphereGroup.add(sphere);
                this.scene.add(this.sphereGroup);

                // --- YENİ: Enerji Küresi ---
                this.orbGroup = new THREE.Group();
                const orbGeometry = new THREE.IcosahedronGeometry(1.8, 64);
                orbGeometry.setAttribute('basePosition', new THREE.BufferAttribute(orbGeometry.attributes.position.array.slice(), 3));
                
                // DÜZELTME: "Full beyaz" sorununu çözmek için ShaderMaterial yerine MeshStandardMaterial kullan.
                // Shader'lar daha karmaşıktır ve ışıklandırma bilgisi gerektirir. Standart materyal daha güvenilirdir.
                const orbMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, 
                    emissive: 0x000000, 
                    metalness: 0.4, 
                    roughness: 0.5 
                });

                const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                this.orbGroup.add(orb);

                // YENİ: İç Çekirdek
                const innerCoreGeom = new THREE.IcosahedronGeometry(0.5, 5);
                const innerCoreMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x333333 });
                const innerCore = new THREE.Mesh(innerCoreGeom, innerCoreMat);
                this.orbGroup.add(innerCore);

                this.scene.add(this.orbGroup);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
                this.scene.add(ambientLight);
                const pointLight = new THREE.PointLight(0xffffff, 0.8);
                pointLight.position.set(5, 5, 5);
                this.scene.add(pointLight);

                this.camera.position.z = 5;
                this.initialized = true;
            },
            update: function(dataArray, beatIntensity, bassAvg = 0, trebleAvg = 0) {
                if (!this.initialized || !dataArray) return; 
                const processedData = processAudioData(dataArray, 64);
                const style = visualizerStyles[currentStyleIndex].name;
                const color = new THREE.Color(getRainbowColor(patternTime));

                this.sphereGroup.visible = style === '3d-sphere';
                this.orbGroup.visible = style === '3d-orb';

                if (style === '3d-sphere') {
                    const sphere = this.sphereGroup.children[0];
                    sphere.rotation.x += 0.001; sphere.rotation.y += 0.002;
                    const positions = sphere.geometry.attributes.position;
                    const basePositions = sphere.geometry.attributes.basePosition;
                    
                    // DÜZELTME: Küre deformasyon mantığını ilk, düzgün çalışan haline geri getir.
                    for (let i = 0; i < positions.count; i++) {
                        const base_x = basePositions.getX(i);
                        const base_y = basePositions.getY(i); 
                        const base_z = basePositions.getZ(i);
                        // DÜZELTME: Yapay destek olmadan, sadece gerçek ses verisine tepki ver
                        const rawValue = processedData[i % processedData.length];
                        const dynamicValue = Math.pow(rawValue, 0.9); // Sadece dinamik sıkıştırma kullan
                        const offset = (dynamicValue / 255) * 0.25 * (1 + beatIntensity);
                        positions.setXYZ(i, base_x * (1 + offset), base_y * (1 + offset), base_z * (1 + offset));
                    } 
                    positions.needsUpdate = true;
                    sphere.geometry.computeVertexNormals();
                    sphere.material.color.lerp(color, 0.1);
                }

                if (style === '3d-orb') {
                    const orb = this.orbGroup.children[0];
                    orb.rotation.x += 0.001; orb.rotation.y += 0.002;
                    const positions = orb.geometry.attributes.position;
                    const basePositions = orb.geometry.attributes.basePosition.array;
                    const newPositions = new Float32Array(basePositions); // Her karede yeni bir dizi oluştur

                    // Deprem Dalgalanması Efekti
                    for (let i = 0; i < positions.count; i++) {
                        const base_x = basePositions[i * 3];
                        const base_y = basePositions[i * 3 + 1];
                        const base_z = basePositions[i * 3 + 2];

                        // Ana "deprem" dalgası (Bastan etkilenir)
                        const bassWave = Math.sin(base_x * 5 + patternTime * 4) * Math.cos(base_y * 5 + patternTime * 2);
                        
                        // Yüzeydeki hızlı "titreşimler" (Tizden etkilenir)
                        const trebleWave = Math.sin(base_y * 25 + patternTime * 20) * Math.cos(base_z * 25 + patternTime * 15);
                        const waveFactor = bassWave + (trebleWave * (trebleAvg / 255) * 0.5);
                        const amplitude = (bassAvg / 255) * 0.08 + beatIntensity * 0.15;
                        const waveOffset = 1.0 + waveFactor * amplitude;

                        newPositions[i * 3] = base_x * waveOffset;
                        newPositions[i * 3 + 1] = base_y * waveOffset;
                        newPositions[i * 3 + 2] = base_z * waveOffset;
                    }
                    
                    // DÜZELTME: Hesaplanmış yeni pozisyonları geometriye ata. Bu en güvenilir yöntemdir.
                    positions.set(newPositions);
                    positions.needsUpdate = true;
                    orb.geometry.computeVertexNormals();

                    // Shader materyalini ve iç çekirdeği güncelle
                    orb.material.color.lerp(color, 0.1); 
                    orb.material.emissive.set(color).multiplyScalar(beatIntensity * 0.5); 

                    const innerCore = this.orbGroup.children[1];
                    innerCore.scale.setScalar(1 + beatIntensity * 0.5);
                    innerCore.material.color.set(getRainbowColor(patternTime + 0.2)); 
                    innerCore.material.emissive.set(getRainbowColor(patternTime + 0.2)).multiplyScalar(0.5);
                }

                this.renderer.render(this.scene, this.camera);
            }
        };

        // Vignette opaklığını kontrol etmek için CSS değişkeni kullanalım
        document.body.style.setProperty('--vignette-opacity', '0');


        // --- YENİ: ARKA PLAN GRID ÇİZİMİ ---
        function drawGrid(beatIntensity) {
            gCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            const step = 50;
            const centerX = gridCanvas.width / 2;
            const horizonY = gridCanvas.height * 0.4;
            const beatGlow = beatIntensity * 200;

            // Grid rengini ana paletten al
            const gridColor = `rgb(${currentPalette[0][0]}, ${currentPalette[0][1]}, ${currentPalette[0][2]})`;

            gCtx.strokeStyle = `rgba(${currentPalette[0].join(',')}, 0.2)`;
            gCtx.shadowColor = `rgba(${currentPalette[0].join(',')}, 0.5)`; // DÜZELTME: Parlama renginin opaklığını azalt
            gCtx.shadowBlur = beatGlow;

            // Yatay çizgiler
            for (let i = 0; i < 20; i++) {
                const y = horizonY + i * i;
                if (y > gridCanvas.height) break;
                gCtx.beginPath();
                gCtx.moveTo(0, y);
                gCtx.lineTo(gridCanvas.width, y);
                gCtx.stroke();
            }

            // Dikey (perspektif) çizgiler
            for (let i = -20; i <= 20; i++) {
                if (i === 0) continue;
                const x = centerX + i * step;
                gCtx.beginPath();
                gCtx.moveTo(centerX, horizonY);
                gCtx.lineTo(x, gridCanvas.height);
                gCtx.stroke();
            }
            gCtx.shadowBlur = 0; // Sonraki çizimleri etkilememesi için sıfırla
        }


        // --- ARKA PLAN PARÇACIK ANİMASYONU ---
        let particlesArray, shootingStars = [], hueShiftAngle = 0;
        class Particle {
            constructor() {
                this.x = Math.random() * particleCanvas.width;
                this.y = Math.random() * particleCanvas.height;
                this.size = Math.random() * 1.5 + 1;
                this.speedX = (Math.random() * 0.4) - 0.2;
                this.speedY = (Math.random() * 0.4) - 0.2;
            }
            update() {
                if (this.x > particleCanvas.width || this.x < 0) { this.speedX = -this.speedX; }
                if (this.y > particleCanvas.height || this.y < 0) { this.speedY = -this.speedY; }
                const speedMultiplier = (currentMode === 'realtime' && smoothedBPM > 0) ? (smoothedBPM / 120) : 1;
                this.x += this.speedX * speedMultiplier;
                this.y += this.speedY * speedMultiplier;
            }
            draw() {
                pCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                pCtx.beginPath();
                pCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                pCtx.fill();
            }
        }
        // YENİ: Yıldız Kayması Efekti
        class ShootingStar {
            constructor() {
                this.reset();
                this.y = Math.random() * particleCanvas.height;
            }
            reset() {
                this.x = Math.random() > 0.5 ? -50 : particleCanvas.width + 50;
                this.y = Math.random() * particleCanvas.height * 0.6; // Ekranın üst %60'ında başlasın
                this.len = Math.random() * 80 + 10;
                this.speed = Math.random() * 5 + 4;
                this.angle = Math.random() * 0.4 - 0.2;
                if (this.x > particleCanvas.width) this.speed = -this.speed;
            }
            draw() {
                const grad = pCtx.createLinearGradient(this.x, this.y, this.x + this.len * Math.cos(this.angle), this.y + this.len * Math.sin(this.angle));
                grad.addColorStop(0, getRainbowColor(patternTime + this.x / particleCanvas.width, 0.6)); // DÜZELTME: Yıldız renginin opaklığını azalt
                grad.addColorStop(1, "transparent");
                pCtx.strokeStyle = grad; pCtx.lineWidth = 2; pCtx.beginPath(); pCtx.moveTo(this.x, this.y); pCtx.lineTo(this.x + this.len * Math.cos(this.angle), this.y + this.len * Math.sin(this.angle)); pCtx.stroke();
            }
        }
        function initParticles() {
            particlesArray = [];
            let numberOfParticles = (particleCanvas.height * particleCanvas.width) / 9000;
            for (let i = 0; i < numberOfParticles; i++) {
                particlesArray.push(new Particle());
            }
        }
        function connectParticles() {
            let opacityValue = 1;
            for (let a = 0; a < particlesArray.length; a++) {
                for (let b = a; b < particlesArray.length; b++) {
                    let distance = ((particlesArray[a].x - particlesArray[b].x) * (particlesArray[a].x - particlesArray[b].x))
                               + ((particlesArray[a].y - particlesArray[b].y) * (particlesArray[a].y - particlesArray[b].y));
                    if (distance < (particleCanvas.width/7) * (particleCanvas.height/7)) {
                        opacityValue = 1 - (distance/20000);
                        pCtx.strokeStyle = `rgba(213, 0, 249, ${opacityValue * 0.2})`; // DÜZELTME: Parçacık bağlantı opaklığını azalt
                        pCtx.lineWidth = 1;
                        pCtx.beginPath();
                        pCtx.moveTo(particlesArray[a].x, particlesArray[a].y);
                        pCtx.lineTo(particlesArray[b].x, particlesArray[b].y);
                        pCtx.stroke();
                    }
                }
            }
        }
        function animateParticles() {
            pCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
            
            // Yıldızları çiz ve güncelle
            if (shootingStars.length > 0) {
                shootingStars.forEach(star => {
                    star.x += star.speed;
                    star.draw();
                    if (star.x < -100 || star.x > particleCanvas.width + 100) star.reset();
                });
            }

            // Parçacıkları çiz ve güncelle
            if (settings.useParticles && particlesArray) {
                for (let i = 0; i < particlesArray.length; i++) particlesArray[i].update();
                for (let i = 0; i < particlesArray.length; i++) particlesArray[i].draw();
                connectParticles();
            }
            if (currentMode === 'simulation' && !isPlaying) {
                hueShiftAngle = (hueShiftAngle + 0.05) % 360;
                bgLayer.style.filter = `blur(${settings.backgroundBlur}px) brightness(0.6) hue-rotate(${hueShiftAngle}deg)`;
            }
            // requestAnimationFrame(animateParticles); // Ana döngüye taşındı
        }
        
        // --- BAŞLANGIÇ ---
        mainLoop(); // ANA ANİMASYON DÖNGÜSÜNÜ HEMEN BAŞLAT
        initializeWidget();

        // Giriş animasyonunun akıcı olması için parçacık motorunu hafif bir gecikmeyle başlat.
        // Bu, tarayıcının ilk animasyona odaklanmasını sağlar ve "kasılma" hissini ortadan kaldırır.
        setTimeout(() => {
            initParticles();
            // YENİ: 3 adet kayan yıldız oluştur
            for(let i=0; i<3; i++) {
                setTimeout(() => shootingStars.push(new ShootingStar()), i * 1500); // Farklı zamanlarda başlasınlar
            }
            resizeCanvas(); // Her şeyin doğru boyutlarda olduğundan emin ol
            // animateParticles(); // Ana döngü zaten çalıştırıyor
        }, 500); // 500 milisaniye (yarım saniye) gecikme
    </script>
</body>
</html>